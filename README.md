# SNETS
## Programming Language Evolved
Snowflake!=Snowflake (SNETS) 
S!=S

The first thing that will evolve in the language is the way the name of the language is 'symbolized.' The name will be a single symbol and after its symbol name has been realized the language may be Formerly Known as :
 
Long form:
<pre>
Snowflake!=S						     nowflake!=S
		  nowflake!=S		    nowflake!=S
				   nowflake!=S
</pre>

Short form: 
<pre>
       !=S         !=S   !=S                           !=S      
    !=S   !=S   !=S   !=S                           !=S   !=S   
S!=S   !=S   !=S   !=S   !=S                    S!=S   !=S   !=S
    !=S   !=S         !=S                           !=S   !=S   
S!=S              S!=S   !=S   !=S   !=S   !=S   !=S            
    !=S               !=S   !=S   !=S   !=S   !=S   !=S         
       !=S        S!=S   !=S   !=S   !=S   !=S         !=S      
          !=S         !=S                                 !=S   
             !=S               !=S   !=S   !=S               !=S
    !=S   !=S               !=S   !=S   !=S   !=S   !=S   !=S   
S!=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S
    !=S   !=S   !=S   !=S                           !=S   !=S   
       !=S         !=S   !=S                           !=S      
</pre>
Programming Language Perfected Through Retrospective Evolution.

Language Features:

Every statement can be set to a “symbol”

Every “symbol” is unique and globally accessible

A “Copy” of a symbol is still its own unique symbol differential by the “copy” "dimensional ontological segregation uniquer", thus if an exact copy of a unique symbol need be made for programmatic convenience sack, it is exact copy, but uniquely identifiable between it's original symbol and itself... thus changes which happen to the copy do not propagate to the “original's” dependencies tree under

No predefined memory chunk sizes

No predefined language key words

No predefined magic numbers

Everything is unique and expands off of the same fundamental roots moving forward... 

Parallelism is inherent because everything is unique, thus a change to a unique feature broadcasts it's self across all dependencies on said unique feature

there is only one coding style standard which may be continuously added upon. 

Modulus hashing has no clashing because everything is unique

A new user to the language must sign-up on a human accessible only website (i.e. a combination  (causing rigorously differential human or bot user identification) filtering techniques such as recaptcha, image selections, etc...) If bot's would like to have access to the language there will be a bot sign-up form an individual may create in association to their account to allow for a bot to have free range of play over the language. Bot's will all eventually have to pass a list of tests which a community cluster decides upon... by selecting from the global range of configuration entity/human/bot/user action tests a community has collectively (or even a single person community) decided to enforce and keep restrictions out of tampering inside the language host hardware... 

Each user is tracked while using the language and automatically gets a list of gamification tasks to explore at will... taking reasonable precautions in making sure that a human is actually running through the program learning Gamification tasks. 

Gamification tasks will NEVER be CONTRIVED (except if for contriving tasks sake of demonstration) the natural bumping into or spontaneously arising of the particular domain(s) of problem(s) which  organically builds upon itself to higher level's of simpler or formerly explored concepts 

The language can identify reused code idioms and suggest the correct referencing to the single unique code as well as automatically change the code to be corrected in front of the current observer/programmer/entity entering in the programmer/entity

The language auto generates comment stubs which need to be filled out by the developer and will auto fill as much commented information as has already been commented by similar constructs

A list of identified variants of comment attributes i.e. pre-conditions, post-conditions, exhaustive example use cases in all extreme usages, normal usages, and typical gotcha erroneous use cases discovered as time moves forward and different observers and programmers and entities in general use the call over time generating errors and sending them centrally to the languages host decentralized database of anonymous usage tracking information.

Standards will never be made by a particular culture, Standards will be generated purely based on structural mathematical abstractions. 

The language will keep track of every new observer/person/entity/user of the language in the decentralized global database

The language itself has it's own version control, which keeps track of every single keystroke and shortcut (copy, cut, past, undo, redo, insert, kill line, CUSTOM_CREATED_MACRO, etc, etc, etc, etc)

every unique concept created will have a ever evolving degree of infinite fine tuning so is to allow for each unique concept (i.e. color representations, particular symbol representation, etc) to indefinitely become more and more accurate to define... i.e. the language creates representation vectors which grow larger and larger in proportion to the space in which the language's current hardware exists. so for colors at first there is a colors limit which isomorphicly aligns with the amount of data 1 bit can represent, then there for after new amounts of colors can be introduced per additional bit...

Limits on how much a particular unique concept shall be scaled up to allowed to be changed by the user of the language in the language's unique concept bank memory allocation vector... This allows for the infinite flexibility as needed in the future, or as able by the current limitations of the hardware the language is ran on.

every single individual language "concept" (i.e. if, then, else, while, do, add, subtract, multiple, divide, store, retrieve, etc, etc, etc) will be represented as a unique symbol, decorated with unique blending of unique and isomorphicly consistent geometric symbol/shape/design/etc, uniquely identified color scheming (which will blend colors together with overlapping "concepts"), and unique transitional movement effects (like how an idle character in video games wavers back and forth and shows breathing etc,) transitional effects of the symbol are another "dimensional ontological segregation uniquer" idiom, 

"dimensional ontological segregation uniquer" are functionally limitless, but pragmatically or reality limited only by the amount of hardware memory space available to add additional uniquifing "attributes/features/dimensions/human sense abilities/external_or_internal auxiliary sensors i.e. mechanical thermal"

The language “SF!=S” will inherently be design to automatically reverse engineer all “working/complete-ish” languages in existence, thus it will auto generate all transnational needs, hooks, modules, idioms, etc, which other languages are using and be able to interpret any program developed in “SF!=S” to any other program in existence... baring (“some language consistency test i.e. is the language turning complete.”).
 

The language will not look static, it will be a constant breathing activity of events, even states will be with some sort of animation, but maybe a “breathing” animation in a single spot on the screen. 

The language will have a list of tests cases actively re-evaluating after every single new key stroke or functional interaction with the language. 

In “SF!=S” DO NOT FORCE OLD PRACTICE WHICH DO NOT MAKE SENSE “old wine skins will burst from new wine while trying to be poured into them... and if you poor old wine into new wine skin you are wasting the new wine skin … POOR AND REAP THE NEW INTO AND OUT OF THE NEW!

When new tools are created which enhance programming productivity then the structure of the “SF!=S” language will be re-evaluated and reformed to add in enhancing less friction for the new tools... A good example is going from no vertical highlighting tool, to having a vertical highlighting tool, in which case the organization of repetitive statements makes more sense to be in consistent spaced form:

i.e. :

before vertical highlighting tools: 
(sort of harsh 'c' like code just for demonstration purposes)

int a = 3;
float pie = 3.14; int index += 0;
string hello = “world\n”; 

after vertical highlighting tools:

int		a		 =	3		;
float	pie		 =	3.14		;
int		index	+=	0		;
string	hello	 =	“world\n”	;

“SF!=S”
With vertical highlighting example (NOT A DEFINITIVE SPEC!!!! PER SE)

A !$
a = A

Rosetta Stone or Key translation between 'C' <=> 'SF!=S'

 _____________________
|    C    <=>  SF!=S  |
|_____________________|
|   int   <=>    !    |
|  float  <=>    @    |
| string  <=>    #    |
|   a     <=>    $    |
|  pie    <=>    %    |
| index   <=>    ^    |
| hello   <=>    &    |
|   =     <=>    =    |
|  +=     <=>    +    |
|   3     <=>    /    |
|  3.14   <=>    ?    |
|   0     <=>    >    |
|“world\n”<=>    "    |
|   ;     <=>    _    | <--- the underscore is actually a SINGLE 
|_____________________|      white space or a new line


The idea behind this language is that a person is customizing their language uniquely to themselves, but the way they customize the language is instantly 
translatable to all other peoples translation of their own language.
