# Snowflake!=S (SNETS)
###### Programming Language Perfected Through Consistent Timed-stamped Perpetually Additive Retrospective Evolutionary Functional Reactive Programming. Mediator of all languages. The final corner Rosetta stone clearly known oracle through explicit elucidation juxtaposing contrast with implicit implications.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_"When the nature of the world is revealed, then the mystery of the sphinx will no longer exist"_ [ [1](http://esotericastrologer.org/newsletters/leo-virgo-the-mystery-of-the-sphinx/) ]
<hr>
## Language Features
The first thing that will evolve in the language is the way the name of the language is 'symbolized.' The name will be a single symbol and after its symbol name has been realized the language may be Formerly Known as :
 
Long form : Snowflake!=S (SNETS) 
<pre>
Snowflake!=S						     nowflake!=S
		  nowflake!=S		    nowflake!=S
				   nowflake!=S
</pre>

Short form : S!=S
<pre>
       !=S         !=S   !=S                           !=S      
    !=S   !=S   !=S   !=S                           !=S   !=S   
S!=S   !=S   !=S   !=S   !=S                    S!=S   !=S   !=S
    !=S   !=S         !=S                           !=S   !=S   
S!=S              S!=S   !=S   !=S   !=S   !=S   !=S            
    !=S               !=S   !=S   !=S   !=S   !=S   !=S         
       !=S        S!=S   !=S   !=S   !=S   !=S         !=S      
          !=S         !=S                                 !=S   
             !=S               !=S   !=S   !=S               !=S
    !=S   !=S               !=S   !=S   !=S   !=S   !=S   !=S   
S!=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S   !=S
    !=S   !=S   !=S   !=S                           !=S   !=S   
       !=S         !=S   !=S                           !=S      
</pre>

Every statement can be set to a “symbol”

Every “symbol” is unique and globally accessible

A “Copy” of a symbol is still its own unique symbol differential by the “copy” "dimensional ontological segregation uniquer", thus if an exact copy of a unique symbol need be made for programmatic convenience sack, it is exact copy, but uniquely identifiable between it's original symbol and itself... thus changes which happen to the copy do not propagate to the “original's” dependencies tree under

No predefined memory chunk sizes

No predefined language key words

No predefined magic numbers

Everything is unique and expands off of the same fundamental roots moving forward... 

Parallelism is inherent because everything is unique, thus a change to a unique feature broadcasts it's self across all dependencies on said unique feature

there is only one coding style standard which may be continuously added upon. 

comprehensive magic number listing association to remind user or programming what the potential magic number could be trying to represent, organized with the statisically highest likely case, based off as much contextual dimensional identifiers with in the language, earth region, time of day etc etc etc...

Comprehensive database of well formed organized exception possible resolution error text, basicically a much more cleaner version of Stackoverflow generated by users who cause the errors and possible solutions... which are further refined for quicker future reference checking.

Modulus hashing has no clashing because everything is unique

A new user to the language must sign-up on a human accessible only website (i.e. a combination  (causing rigorously differential human or bot user identification) filtering techniques such as recaptcha, image selections, etc...) If bot's would like to have access to the language there will be a bot sign-up form an individual may create in association to their account to allow for a bot to have free range of play over the language. Bot's will all eventually have to pass a list of tests which a community cluster decides upon... by selecting from the global range of configuration entity/human/bot/user action tests a community has collectively (or even a single person community) decided to enforce and keep restrictions out of tampering inside the language host hardware... 

Each user is tracked while using the language and automatically gets a list of gamification tasks to explore at will... taking reasonable precautions in making sure that a human is actually running through the program learning Gamification tasks. 

Gamification tasks will NEVER be CONTRIVED (except if for contriving tasks sake of demonstration) the natural bumping into or spontaneously arising of the particular domain(s) of problem(s) which  organically builds upon itself to higher level's of simpler or formerly explored concepts 

The language can identify reused code idioms and suggest the correct referencing to the single unique code as well as automatically change the code to be corrected in front of the current observer/programmer/entity entering in the programmer/entity

The language auto generates comment stubs which need to be filled out by the developer and will auto fill as much commented information as has already been commented by similar constructs

A list of identified variants of comment attributes i.e. pre-conditions, post-conditions, exhaustive example use cases in all extreme usages, normal usages, and typical gotcha erroneous use cases discovered as time moves forward and different observers and programmers and entities in general use the call over time generating errors and sending them centrally to the languages host decentralized database of anonymous usage tracking information.

Standards will never be made by a particular culture, Standards will be generated purely based on structural mathematical abstractions. 

The language will keep track of every new observer/person/entity/user of the language in the decentralized global database

The language itself has it's own version control, which keeps track of every single keystroke and shortcut (copy, cut, past, undo, redo, insert, kill line, CUSTOM_CREATED_MACRO, etc, etc, etc, etc)

every unique concept created will have a ever evolving degree of infinite fine tuning so is to allow for each unique concept (i.e. color representations, particular symbol representation, etc) to indefinitely become more and more accurate to define... i.e. the language creates representation vectors which grow larger and larger in proportion to the space in which the language's current hardware exists. so for colors at first there is a colors limit which isomorphicly aligns with the amount of data 1 bit can represent, then there for after new amounts of colors can be introduced per additional bit...

Limits on how much a particular unique concept shall be scaled up to allowed to be changed by the user of the language in the language's unique concept bank memory allocation vector... This allows for the infinite flexibility as needed in the future, or as able by the current limitations of the hardware the language is ran on.

every single individual language "concept" (i.e. if, then, else, while, do, add, subtract, multiple, divide, store, retrieve, etc, etc, etc) will be represented as a unique symbol, decorated with unique blending of unique and isomorphicly consistent geometric symbol/shape/design/etc, uniquely identified color scheming (which will blend colors together with overlapping "concepts"), and unique transitional movement effects (like how an idle character in video games wavers back and forth and shows breathing etc,) transitional effects of the symbol are another "dimensional ontological segregation uniquer" idiom, 

"dimensional ontological segregation uniquer" are functionally limitless, but pragmatically or reality limited only by the amount of hardware memory space available to add additional uniquifing "attributes/features/dimensions/human sense abilities/external_or_internal auxiliary sensors i.e. mechanical thermal"

The language “SF!=S” will inherently be design to automatically reverse engineer all “working/complete-ish” languages in existence, thus it will auto generate all transnational needs, hooks, modules, idioms, etc, which other languages are using and be able to interpret any program developed in “SF!=S” to any other program in existence... baring (“some language consistency test i.e. is the language turning complete.”).
 

The language will not look static, it will be a constant breathing activity of events, even states will be with some sort of animation, but maybe a “breathing” animation in a single spot on the screen. 

The language will have a list of tests cases actively re-evaluating after every single new key stroke or functional interaction with the language. 

In “SF!=S” DO NOT FORCE OLD PRACTICE WHICH DO NOT MAKE SENSE “old wine skins will burst from new wine while trying to be poured into them... and if you poor old wine into new wine skin you are wasting the new wine skin … POOR AND REAP THE NEW INTO AND OUT OF THE NEW!

One possible idea behind this language is that a person is customizing their language uniquely to themselves, but the way they customize the language is instantly 
translatable to all other peoples translation of their own language.

Another language feature is hovering over each symbol reveals the current language text the individual understands, and where the individual's language text does not have
a word for it, then lateral words are chosen to help describe the meaning, but it's NOTED IN OBVIOUS PRESENTATION that this is only a vague description, and that the 
individual's spoken language has reach it's limit's of describablity.

We will need a random unique symbol generator which will be able to automatically be created by attributing two other symbols together potentially using a modified version of
a genetic algorithm, which also has the insurance of never repeating a scenario... 
There is a universal dictionary which gets checked globally on the decentralized torrent/cloud language to add in finding out if an overlaps in code has been typed, and if so 
then the language downloads that code and shows the user what has already been done with that particular line of code as well as other dependencies both parental and child or lateral
dependencies a like.

We will need a new keyboard that has LCD displayed images for keys so that our programming language symbols can start to auto-remap against the keyboard's layout assisting in
bringing most recent or relevant symbols that are needed next closer to the center of the keyboard where they figures are used the most... in fact the “DataHand Keyboard” is
what is needed to reduce the geometric distance between key presses as well as reduce the amount of ware and tare on a human's hands. “DataHands” all will be 100% customization

Raster Fonts and Fonts Tools in General will be used to create the "dimensional ontological segregation uniquifiers", and 3D boxes and transparent coloring and shading effects etc
will all be apart of assisting in developing the language's differentiating paradigms/isomorphic overlaps etc...

When new tools are created which enhance programming productivity then the structure of the “SF!=S” language will be re-evaluated and reformed to add in enhancing less friction for the new tools... A good example is going from no vertical highlighting tool, to having a vertical highlighting tool, in which case the organization of repetitive statements makes more sense to be in consistent spaced form:

<pre>
int		a		 =	3			;
float	pie		 =	3.14		;
int		index	+=	0			;
string	hello	 =	“world\n”	;
</pre>
<pre-wrap>
“S!=S”
With out vertical highlighting example (NOT A DEFINITIVE SPEC!!!! PER SE)
</pre-wrap>
<pre>
"comments are within quotes"
"^the above line is the first line in the S!=S"
`KS <--- known snowflakes the language's basics starting point.

"Potential ways S!=S could be translated from the C code above"
"Vertical Separations"
!$ A   
A/ 5
@% B
B? 7
!^ C
C+ D
D> E 
#& F
F* G

"Horizontal Separations"
!$ A A/ 5 @% B B? 7 !^ C C+ D D> E #& F F* G
</pre>
<pre-wrap>
"The above two forms show a few dilemmas one being redundancy and two readability, as far as we know currently"
"Lets solve one dilemma at a time. First dilemma stated was redundancy, how can we get rid of redundancy?"
"Here are the above two programs with a reduction in redundancy"
</pre-wrap>
<pre>
"Vertical Separations"
!$ A
/ 5 
@% B
? 7 
!^ C
+ D
> E 
#& F
* G

"Horizontal Separations"
!$ A/ 5 @% B? 7 !^ C+ D> E #& F* G
</pre>
<pre-wrap>
"Note there is still one redundancy not taken care of, which is the ! 'snowflakes' being used twice, we've discovered another dilemma, which we'll attend to after our first two dilemma's have been resolved"
"The second dilemma we initially found was readability. All 4 of the above programs could be said to be a bit illegible, due to the monotonic pure form idealization of using only"
"consistent vertical form xor horizontal form."
</pre-wrap>
<pre>

"Here is a potential solution to our readability dilemma"
!$ A
   / 5
@% B
   ? 7
!^ C
   + D
     > E
#& F
   * G
</pre>
<pre-wrap>
"now the code has some mixed structural combinations of the horizontal and vertical reduced forms"
"We now can see the edge of each full statement and its newly associated auto-generated unique snowflake"
"we'll allow for the language to have flexibility between how the code layout is accepted, by tweaking the language's configuration settings 'file'"

"The 3rd dilemma we found after the initial first go at reducing the redundancies we now can take a further look into"
</pre-wrap>
<pre>
"One option to eliminate this redundancy would to just put the ^ next to the $ sign as follow:"
!$^ A
   / 5
@% B
   ? 7
   
   + D
     > E
#& F
   * G
 </pre>
 <pre-wrap>
"but now that we have removed the redundant line by 'listing' it with the same symbol we have caused two more dilemma. One dilemma is how do we know what to assign '^' to in coherence"
"to our every statement is unique rule? Currently we still only have 'A' as being assigned to the 3 signs '!$^' this will need some work. another dilemma is now that we have removed"
"the !^ C 'statement' or 'line' there are cascading future assignments which no longer have a place to associate against"

"Lets tackle the first dilemma with !$^"
"First lets say what we mean to say in a familiar language's syntax structure:"
"in C we would be saying something a kin to int a = 3, index += 0;"
</pre-wrap>
<pre>
"so rewriting our S!=S code, based on this C form and using our"
"Rosetta Stone 1 to 1 Key translator forms the following"
!$ A
   / 5
     ^+ D
	    > E
		
"Now it looks like we will need to create a rule for the cascading"
"scenario which takes shape similar to the junction between"
"[BEGINNING LINE STARTS HERE]s[3]/s[1]5[\r\n]s[5]^+s[1]D"
"[BEGINNING LINE STARTS HERE] signifies we know after the ] bracket is the beginning of a line.
"s[3] meaning 3 spaces," 
"s[1] meaning 1 space,"
"[\r\n] meaning return then newline,"
"s[5] meaning 5 spaces."

"Taking a deeper look at the junction point"
   / 5
     ^+ D
	    > E
"what we find is a scenario which creates the generalized pattern of"
"s[k]sign[1]s[1]sign[1][\r\n]s[k+2]sign[2]s[1]sign[1][\r\n]s[k+5]sign[1]s[1]sign[1]"
"s[k] means k spaces"
"s[k+2] means k+2 spaces"
"s[k+5] means k+5 spaces"
"k is used instead of a number because the tree breath will vary in length,"
"and we need a reference of how far k+2 spaces is given a known distance from"
"the starting line to the first sign[1] at a junction in the form of the 
"generalized pattern above."


"Given this form as the state in which a situation where two variables are"
"being initialized concurrently to reduce redundancy of use of the sign ! we"
"simply say when we see this generalized pattern it means exactly"
"sign[2]s[1]sign[1][\r\n]s[k] back is being used for our datatype signature"
"to be uniquely copied... thus originally we had entered"

!$ A
   / 5
@% B
   ? 7
!^ C
   + D
     > E
#& F
   * G
</pre>
<pre-wrap>
"This is a potential way to space the code for better readability Plus using dynamic closures which show the state of the code with dummy values"
"Dummy values will be auto generated in a closure file. The generation of the snowflakes will be pulled from analysis of what may appropriately fit the datatype"
"an idea would show a window section which displays the closure snowflakes to values configurations generated via the context of the entire language"
</pre-wrap>
<pre>
!$ A
   / 5
@% B
   ? 7
!^ C
   + D
     > E
#& F
   * G

Rosetta Stone or Key translation between 'C' <=> 'S!=S'
 _____________________
|____C____<=>__SF!=S__|
|   int   <=>    !    |
|  float  <=>    @    |
| string  <=>    #    |
|   a     <=>    $    |
|  pie    <=>    %    |
| index   <=>    ^    |
| hello   <=>    &    |
|   =     <=>         | <---++
|  +=     <=>    +    |
|   3     <=>    /    |
|  3.14   <=>    ?    |
|   0     <=>    >    |
|“world\n”<=>    *    |
|   ;     <=>    _    | <---&&
|_____________________|
</pre>
<pre-word>
++ the equal's operator is implicit between two contiguous snowflakes and a space followed by another symbol note the user only ever enters two snowflakes, a unique symbol is generated automatically after two snowflakes have been typed next to each other
&&  the underscore is actually a SINGLE white space or a RETURN NEWLINE
</pre-word>
